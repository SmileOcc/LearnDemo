
原文链接：https://blog.csdn.net/Deft_MKJing/article/details/82868900

#HTTP缺点
http 无非就是应用层的协议，请求行，请求头，请求体，响应头，响应体，状态码等http传输协议格式

HTTP缺点
通信使用明文，可能被窃听
不验证通信方的身份，可能遭遇伪装
无法证明报文的完整性，有可能遭遇篡改


#HTTPS底层原理（SSL握手详解）

ps: [readFile] 中搜索：HTTPS底层原理（SSL握手详解）

[HTTP+加密+认证+完整性保护 = HTTPS]

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。

TLS/SSL全称[安全传输层协议]Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，
所以使用HTTPS基本上不需要对HTTP页面进行太多的改造


HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：

对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
对网站服务器进行真实身份认证
HTTPS协议的主要功能基本都依赖于TLS/SSL协议，

TLS/SSL的功能实现主要依赖于三类基本算法：
散列函数 Hash、
对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，
对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。


[散列函数Hash]

常见的有 MD5、SHA1、SHA256，该类函数特点是函数[单向不可逆、对输入非常敏感、输出长度固定]，
针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性; 

在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，
中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;

[对称加密]

常见的有AES-CBC、DES、3DES、AES-GCM等，
相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 

对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制;

[非对称加密]

即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，
密钥成对出现，一般称为公钥(公开)和私钥(保密)，
公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。
因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，
服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 

非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，
但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。

结合三类算法的特点，TLS的基本工作方式是，
客户端使用[非对称加密与服务器进行通信]，实现身份验证并协商对称加密使用的密钥， 
然后[对称加密]算法采用协商密钥对信息以及信息摘要进行加密通信，
不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。



#普通RSA身份验证的隐患
身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:

[中间人攻击拦截]
客户端C和服务器S进行通信，[中间节点M] 截获了二者的通信;
节点M自己计算产生一对公钥pub_M和私钥pri_M;
C向S请求公钥时，M把自己的公钥pub_M发给了C;
C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，
而 C无法根据公钥信息判断服务器的身份，从而 C和 * M之间建立了"可信"加密连接;
中间节点 M和服务器S之间再建立合法的连接，
因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。
另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。


#证书和SSL握手底层原理
https://img-blog.csdn.net/20180927212815286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlZnRfTUtKaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70

证书制作：

1.服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;

2.CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;

3.如信息审核通过，CA会向申请者签发认证文件-证书。 证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名; 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;

注意点：
服务器自己有一套公钥私钥，传输是不安全的，就是上面提到的RSA隐患，因此介入了CA权威机构，申请的时候把公钥给CA进行验证，然后CA拿着公钥一起其他信息弄成证书。先把证书理解成一段数据，然后把这个数据进行HASH摘要算法，然后CA公司有自己的私钥，拿着这个私钥把摘要进行RAS加密，加密后的数据就是签名。因此证书就是明文公钥等其他信息，加上CA公司用他们自己私钥签名的一个文件。详细可以看上面的证书图
https://img-blog.csdn.net/2018092721232097?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlZnRfTUtKaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70



#SSL握手

首先明白网络各层的协议和作用，可以参考文章头部的链接。[SSL握手]是发生在[TCP三次握手之后]的

[第一阶段：ClientHello]

客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，[随机数random_C]，扩展字段等信息。

[第二阶段：ServerHello－ServerHelloDone]

如上图可以看出这个阶段包含4个过程( 有的服务器是单条发送，有的是合并一起发送)。
服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法、[随机数random_S] 等，其中随机数用于后续的密钥协商。
服务器也会配置并返回对应的证书链Certificate，用于身份验证与密钥交换。
然后会发送ServerHelloDone信息用于通知服务器信息发送结束。

这里1和2的随机数现在客户端和服务端都有了，后续会用到

[第三阶段：证书校验]

客户端这边还需要对服务器返回的[证书进行校验]。只有证书验证通过后，才能进行后续的通信。(具体分析可参看后续的iOS证书验证过程)

简单介绍下：
1.明白证书的组成，就是上面那段介绍证书制作的过程，服务器把证书传输给客户端的时候，我们是能看到证书公钥信息，过期时间，序列号等明文信息的，还有一个CA的签名（签名算法很重要，用来身份验证）。
2.如果没有这个签名，我们直接拿到明文公钥信息，鬼知道是不是真的？重点来了，签名是RAS了摘要算法，RSA的密钥就是CA的密钥，那么解密只能用CA的公钥解。这里千万区分开了，这里的公钥和我们服务器的公钥是不一样的，整个过程是有两对RSA密钥的。千万别搞错了。这就涉及到了电脑，手机等硬件里面的根证书列表的。正常情况下，生产的时候就会把权威机构的例如CA的公钥加入进去。然后Apple给我们提供了这个方法 SecTrustEvaluate 用来验证证书的。一样先用系统的根证书列表拿到对应的公钥进行解密服务器传过来证书里面的签名，这里解出来的是例如是MD5的摘要值，这个值是我们之前拿公钥去CA认证的时候摘要出来的。然后客户端也拿出证书的明文进行MD5，把这两个值一比对，如果相同，可以验证两个观点。
第一，认证服务器的公开密钥的是真实有效的数字证书认证机构。（因为公私药是成对的，能解开说明是CA机构的）
第二，服务器的公开密钥是值得信赖的。（MD5没变，说明是原装的，肯定是值得信赖的公钥，没被篡改）
先记得一点，这种验证，只能说明这个[证书是正规机构颁发]的而已，而且信息没被篡改，但是如何确定是我自己服务器的证书？后面有介绍
 

[第四阶段：ClientKeyExchange－Finished]

服务器返回的证书验证合法后， 客户端计算产生随机数字[Pre-master Key（预设主密钥）]，并用server证书中公钥加密，发送给服务器。
同时客户端会根据已有的[三个随机数]根据相应的生成[协商密钥]（主密钥+两个随机数通过复杂算法生成[真正的传输密钥]）。
客户端会通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。
然后客户端发送Finished消息用于通知客户端信息发送结束。


[第五阶段：服务器端生成协商密钥]

服务器也会根据已有的[三个随机数]使用相应的算法[生成协商密钥]，
会通知客户端后续的通信都采用协商的通信密钥和加密算法进行加密通信。
然后发送Finished消息用于通知服务器信息发送结束。

[第六阶段：握手结束]

在握手阶段结束后，客户端和服务器数据传输开始使用[协商密钥]进行加密通信。


以上就是HTTPS证书原理和SSL层协议的原理，解决了文章头部提出的三个HTTP的问题

通信使用明文，可能被窃听（协商加密解决）
不验证通信方的身份，可能遭遇伪装 （客户端验证证书机制和原理）
无法证明报文的完整性，有可能遭遇篡改 （验证HASH摘要是否一致）


#问题一 为什么最后客户端和服务端都要发送一个Finish报文？

上面已经提及，Finish报文是对至今全部报文的整体校验值（也就是HASH值）。当客户端把这个值通过得到的公钥进行加密的时候，服务器得到之后对其进行解密，然后再对全部报文进行一个HASH求值。如果这个值跟解密得到的值相等的话，那么说明客户端是可信赖的。
同样的，服务器发送这样的一个整体校验值，用来客户端验证服务器是否是真正要进行通信的那一个。
综上，这个Finish报文就是用来校验双方的身份的。


#问题二 整个过程中产生的三个随机数有什么用呢？

还有，后面进行HTTP通信的时候，是用哪一个密钥进行加密，还有怎么保证报文的完整性。
对于客户端：
当其生成了Pre-master secret之后，会结合原来的A、B随机数，用DH算法计算出一个master secret，紧接着根据这个master secret推导出hash secret和session secret。

对于服务端：
当其解密获得了Pre-master secret之后，会结合原来的A、B随机数，用DH算法计算出一个master secret，紧接着根据这个master secret推导出hash secret和session secret。

在客户端和服务端的master secret是依据三个随机数推导出来的，它是不会在网络上传输的，只有双方知道，不会有第三者知道。同时，客户端推导出来的session secret和hash secret与服务端也是完全一样的。

那么现在双方如果开始使用对称算法加密来进行通讯，使用哪个作为共享的密钥呢？过程是这样子的：

双方使用对称加密算法进行加密，用hash secret对HTTP报文做一次运算生成一个MAC，附在HTTP报文的后面，然后用session-secret加密所有数据（HTTP+MAC），然后发送。

接收方则先用session-secret解密数据，然后得到HTTP+MAC，再用相同的算法计算出自己的MAC，如果两个MAC相等，证明数据没有被篡改。

MAC(Message Authentication Code)称为报文摘要，能够查知报文是否遭到篡改，从而保护报文的完整性。


#问题三 为什么要使用三个随机数呢？

网友dog250是这么解释的：

 "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master secret本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre-master secret的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre-mastersecret就有可能被猜出来，那么仅适用pre-master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre-master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"
1
注：我们在计算机所使用的随机数都是伪随机，而不是物理上所说的真正随机。

另外，黑客可能拦截了这样的一个加密的报文，他不对报文进行修改，而是不停的向报文的接受者发送重复的报文，以扰乱通信的建立。于是，就可以加这么一个随机数。只要任何一个通信方，接收到的报文中的随机数出现重复的情况，就可以知道有中间者对通信的过程进行了扰乱，可以立即中断通信。

#问题四 如果黑客拦截了服务器把证书发送给客户端，并对证书进行恶意修改，会出现什么情况？

第一种情况，假如黑客只是单纯的修改数字证书中的内容，那么由于数字签名的存在，客户端会很容易的判断出报文是否被篡改。

第二种情况，黑客不仅修改了数字证书的内容，并且把数字签名替换掉了，由于黑客不可能知道CA的私钥，于是在客户端用CA的公钥进行解密的时候，解密之后得不到正确的信息，也很容易判断出报文是否被修改。

第三种情况，黑客恶意的从相同的第三方CA申请了一个数字证书。由于这个CA是真实存在的，所以客户端是可以用CA的公钥进行解密，得到了黑客提供的数字证书中的公钥。
但是，由于数字证书在申请的时候，[会绑定一个域名]，
当客户端比如说浏览器，检测到这个数字证书中的域名和我们现在网页访问的域名不一致，
便会发出警告，此时我们也能得知数字证书被替换了。发出的警告如下：[此网站的安全证书有问题]



安全处理相关

可以看到中间人攻击就是中间人想方设法让你信任他的证书到根证书列表，如果信任了，基本的HTTPS验证就能通过，数据就可以被抓包了。如果开启强域名校验，中间人跟着伪造了域名，你也一样会信任。如何根据自身环境选择方案？

1.即使信任根证书，也能被信任的方式攻击，如果加了强域名，中间人跟着证书域名一样会被攻击，那么只能把证书埋进去，做AFSSLPinningModePublicKey和AFSSLPinningModeCertificate这两个模式的验证，就是AF后续的几个if逻辑

2.双向验证模式（参考链接）

3.给我们自己传输的请求体或者服务端给的json数据再来一套RSA和AES加密，即使被攻击，别人也只能看到一串乱码




#---------------------------------


#详细总结介绍Get和Post，Session和Cookies，Token和Cookies自登陆的思路

Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份



#===Cookie：

工作流程：

1. servlet创建cookie，保存少量数据，发送浏览器。
2. 浏览器获得服务器发送的cookie数据，将自动的保存到浏览器端。
3. 下次访问时，浏览器将自动携带cookie数据发送给服务器。
cookie操作

1.创建cookie：new Cookie(name,value)
2.发送cookie到浏览器：HttpServletResponse.addCookie(Cookie)
3.servlet接收cookie：HttpServletRequest.getCookies()  浏览器发送的所有cookie
cookie特点

1. 每一个cookie文件大小：4kb ， 如果超过4kb浏览器不识别
2. 一个web站点（web项目）：发送20个
3.一个浏览器保存总大小：300个
4.cookie 不安全，可能泄露用户信息。浏览器支持禁用cookie操作。
5. 默认情况生命周期：与浏览器会话一样，当浏览器关闭时cookie销毁的。---临时cookie



#session原理分析：

首先浏览器请求服务器访问web站点时，程序需要为客户端的请求创建一个session的时候，
服务器首先会检查这个客户端请求是否已经包含了一个session标识、称为SESSIONID，

如果已经包含了一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，
如果客户端请求不包含session id，则服务器为此客户端创建一个session并且生成一个与此session相关联的session id，sessionid 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串

，这个sessionid将在本次响应中返回到客户端保存，[保存这个sessionid的方式就可以是cookie]，
这样在交互的过程中，浏览器可以自动的按照规则把这个标识发回给服务器，服务器根据这个sessionid就可以找得到对应的session，又回到了这段文字的开始。



#问题一：什么是cookie和什么是session？

cookie是一种在客户端记录用户信息的技术，因为http协议是无状态的，为了解决这个问题而产生了cookie。记录用户名等一些应用

session是一种在服务端记录用户信息的技术，一般session用来在服务器端共享数据，

session一般情况下依赖于cookies，session创建出来把id通过cookies传递，然后session可以存在内存中比如redis，亦或者存入mysql，主要看你服务端的配置

#问题二：cookie的工作原理？session的工作原理？

cookie工作原理，可以看上面讲解cookie的那张图，cookie是由服务器端创建发送回浏览器端的，并且每次请求服务器都会将cookie带过去，以便服务器知道该用户是哪一个。其cookie中是使用键值对来存储信息的，并且一个cookie只能存储一个键值对。所以在获取cookie时，是会获取到所有的cookie，然后从其中遍历。

session的工作原理就是依靠cookie来做支撑，第一次使用request.session时session被创建，并且会为该session创建一个独一无二的sessionid存放到cookie中，然后发送会浏览器端，浏览器端每次请求时，都会带着这个sessionid，服务器就会认识该sessionid，知道了sessionid就找得到哪个session。以此来达到共享数据的目的。 这里需要注意的是，session不会随着浏览器的关闭而死亡，而是等待超时时间。



#--------------------------------

#问题三：为什么需要使用cookie和session

可以看看那个会员卡的例子，cookie和session只是为了解决http协议无状态的这种缺陷，为了记录用户信息，记录浏览器和服务器之间的状态和衍生出来的。


问题六：我们一般认为 Cookie 运行在客户端而 Session 运行在服务器端，所以当我们关闭浏览器（即将客户端和服务器端的链接断开）时，Session 一般就消失了而 Cookie 可以保留。这是真的吗？

虽然Session的确是运行在服务器的，但是sessionID却通过Cookie保存在客户端，所以也不尽然。可以自己设置失效是只存在内存中还是本地也存储

 

问题七：浏览器禁止 Cookie，Cookie 就不能用了，但 Session 不会受到影响，这是真的吗？

禁止了Cookie，页面的SessionID将无法使用PHPSESSID进行传递，大家可以先登陆某一网站，然后删除浏览器数据，会发现刷新页面或切换页面后将丢失登陆状态，当然我们可以用其他方式替代Cookie进行Session传值，但是很明显，Session会受Cookie禁用的影响。

问题八：Session 是否真的比 Cookie 更加安全呢？

存在本地的 Cookie 确实存在一些不安全因素，但是没人会把安全验证完全放在前端，而且我们知道一般 Session 是通过 sessionID 和 Cookie 进行绑定的，客户端的 Cookie 一旦被劫持就相当与 Session 被劫持，服务器验证 Cookie 的同时将原封不动地完成对Session的验证，所以Session比Cookie安全纯属无稽之谈。

问题九：我们发现，使用 IE 登陆腾讯网后，在同一台机子上使用 Firefox 打开腾讯的页面，发现已经有了登陆的状态，那么是否说明 Cookie 可以在不同浏览器之间共享呢？

cookie是由浏览器等客户端完全独立管理的。因为不同浏览器的Cookie管理机制不同，所以cookie不可能在浏览器之间共享。对于这个问题，其实是因为我们在安装腾讯QQ时自动安装了针对不同浏览器的插件，可以识别已经登陆的QQ号码而自动登陆。朋友们可以试试把QQ完全卸载再从网页登陆腾讯网，所以这和Cookie共享是完全没有任何关系的。

问题十：如果把别人的 Cookie 复制到我的电脑上，假设我使用一样的浏览器，那么我是否可以直接登陆别人的账号呢？

原则上讲是可行的，我们将其称为 Cookie 劫持，然而我们可以通过在 Cookie 中加入基于IP等特定信息的参数优化 Cookie 的验证过程，从而避免这一危险。



#---------------------------------


在三次握手和四次挥手中会经常看到 SYN、ACK 和 FIN 的身影，一共有 6 个标志位，它们表示的意义如下：

URG (Urgent Bit)：值为 1 时，紧急指针生效

ACK (Acknowledgment Bit)：值为 1 时，确认序号生效

PSH (Push Bit)：接收方应尽快将这个报文段交给应用层

RST (Reset Bit)：发送端遇到问题，想要重建连接

SYN (Synchronize Bit)：同步序号，用于发起一个连接

FIN (Finish Bit)：发送端要求关闭连接


#============ 三次握手

第一次握手：

客户端向服务器发送报文段1
其中的 SYN 标志位的值为 1表示这是一个用于请求发起连接的报文段

序号字段（seq）被设置为初始序号x（(Initial Sequence Number，ISN)， TCP 连接双方均可随机选择初始序号

发送完报文段1之后，客户端进入 SYN-SENT 状态，等待服务器的确认。

第二次握手：

服务端在收到客户端的连接请求后，像客户端发送报文段2作为应答

其中的ACK 标志位设置为 1，表示对客户端做出应答

其ack(确认序号) 生效,该字段的值为x+1(也就是从客户端收到的报文段的序号加1),代表服务器期望下次收到客户端的数据的序号

其也有SYN标志位为1，代表这同时也是一个用于发起连接的报文段，序号 seq 设置为服务器初始序号y。发送完报文段2后，服务器进入 SYN-RECEIVED 状态。

第三次握手

客户端在收到报文段2后，向服务器发送报文段3
其 ACK 标志位为1，代表对服务器做出应答

确认序号字段 ack 为 y + 1，序号字段 seq 为 x + 1。

此报文段发送完毕后，双方都进入 ESTABLISHED 状态，表示连接已建立。



#TCP 建立连接为什么要三次握手而不是两次？

防止已过期的连接请求报文突然又传送到服务器，因而产生错误
三次握手才能让双方均确认自己和对方的发送和接收能力都正常

示例如下
在双方两次握手即可建立连接的情况下，假设客户端发送 [A 报文段]请求建立连接，
由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段.

由于客户端在长时间得不到应答的情况下[重新发送请求报文段 B]，这次 B 顺利到达服务器，
服务器随即返回确认报文并进入 ESTABLISHED 状态,客户端在收到 确认报文后也进入 ESTABLISHED 状态,双方[建立连接]并传输数据

如果之后客户端正常断开连接，然而此时[姗姗来迟的 A 报文段]才到达服务器，
服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的[客户端无法再接受确认报文段]，
更无法进入 ESTABLISHED 状态，这将导致[服务器长时间单方面等待，造成资源浪费]。



#TCP 建立连接为什么要三次握手而不是四次？

相比上个问题而言，这个问题就简单多了。因为三次握手已经可以确认双方的发送接收能力正常，
双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。



#有一种网络攻击是利用了 TCP 建立连接机制的漏洞，你了解吗？这个问题怎么解决？

在三次握手过程中，服务器在收到了客户端的 SYN 报文段后，会分配并初始化连接变量和缓存，并向客户端发送 SYN + ACK 报文段，这相当于是打开了一个“半开连接 (half-open connection)”，会消耗服务器资源。如果客户端正常返回了 ACK 报文段，那么双方可以正常建立连接，否则，服务器在等待一分钟后会终止这个“半开连接”并回收资源。

这样的机制为 SYN洪泛攻击 (SYN flood attack)提供了机会，
这是一种经典的 DoS攻击 (Denial of Service，拒绝服务攻击)，
所谓的拒绝服务攻击就是通过进行攻击，使受害主机或网络不能提供良好的服务，从而间接达到攻击的目的。
在 SYN 洪泛攻击中，[攻击者发送大量的 SYN 报文段]到服务器请求建立连接，
但是[]却不进行第三次握手，这会导致服务器打开大量的半开连接，消耗大量的资源，最终无法进行正常的服务。


解决方案：

SYN Cookies，现在大多数主流操作系统都有这种防御系统。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。
它的原理是，在服务器接收到 SYN 报文段并返回 SYN + ACK 报文段时，不再打开一个半开连接，也不分配资源，
而是根据这个 [SYN 报文段的重要信息] (包括源和目的 IP 地址，端口号可一个秘密数)，利用特定散列函数计算出一个 cookie 值。
[这个 cookie 作为将要返回的SYN + ACK 报文段的初始序列号(ISN)]。
当客户端返回一个 ACK 报文段时，服务器根据首部字段信息计算 cookie，与返回的确认序号(初始序列号 + 1)进行对比，
如果相同，则是一个正常连接，然后分配资源并建立连接，否则拒绝建立连接。



#--------------------------------

#四次挥手

建立一个连接需要三次握手，而终止一个连接要经过 4次握手。
原因：这由 TCP 的半关闭( half-close) 造成的。既然一个 TCP 连接是全双工 (即数据在两个方向上能同时传递)，因此每个方向必须单独地进行关闭。

这原则就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向连接。
当一端收到一个 FIN，它必须通知应用层另一端已经终止了数据传送。理论上客户端和服务器都可以发起主动关闭，但是更多的情况下是客户端主动发起。




四次挥手详细过程如下：

第一次挥手：

客户端发送关闭连接的报文段，FIN 标志位1，请求关闭连接，并停止发送数据。

序号字段 seq = x (等于之前发送的所有数据的最后一个字节的序号加1)，然后客户端会进入 FIN-WAIT-1 状态，等待来自服务器的确认报文。

第二次挥手：

服务器收到 FIN 报文后，发回确认报文，ACK = 1， ack = x + 1，并带上自己的序号 seq = y

然后服务器就进入 CLOSE-WAIT 状态。服务器还会通知上层的应用程序对方已经释放连接。

此时 TCP 处于半关闭状态，也就是说客户端已经没有数据要发送了，但是服务器还可以发送数据，客户端也还能够接收。
客户端收到服务器的 ACK 报文段后随即进入 FIN-WAIT-2 状态，此时还能收到来自服务器的数据，直到收到 FIN 报文段。
第三次挥手：

服务器发送完所有数据后，会向客户端发送 FIN 报文段，FIN=1,ACK=1,ack=x+1,seq=z，随后服务器进入 LAST-ACK 状态，等待来自客户端的确认报文段。
第四次挥手：

客户端收到来自服务器的 FIN 报文段后，向服务器发送ACK=1,ack=z+1,seq=x+1,，随后进入 TIME-WAIT 状态。

[等待 2MSL(2 * Maximum Segment Lifetime，两倍的报文段最大存活时间)]，
这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入 CLOSED 状态。

服务器在接收到客户端的报文段ACK=1后会随即进入 CLOSED 状态，由于没有等待时间，一般而言，服务器比客户端更早进入 CLOSED 状态。


四次挥手面试题？

#为什么 TCP 关闭连接为什么要四次而不是三次？

服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接。

但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据。

在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接

然后客户端再做出应答，因此一共需要四次挥手。


#客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？

按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入 CLOSED 状态了.

但是网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段，这显然不是我们想要的.
所以客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间。

如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间。

如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。



#TCP长连接和短连接

短连接就是每次数据的收发都会三次握手和四次挥手，
而长连接就会建立一次连接，然后不断收发数据。
很明显，前者耗时，每次都要握手和挥手，后者就是占服务器资源。
