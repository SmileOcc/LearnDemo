

#Swift Any、AnyObject和Generics区别

[Any：]
Any 是 Swift 中的⼀种类型擦除（type erasure）的概念，是⼀个协议（protocol）。
使用 Any 声明的变量可以存储任何类型的值，包括值类型和引⽤类型。
Any 是 Swift 中的一个特殊类型，用于表示任意类型的实例。
使⽤ Any 时， Swift 编译器会[放弃类型检查]，因此需要⼩⼼使⽤，避免类型错误。

[AnyObject：]
AnyObject 是 Swift 中的⼀个协议（ protocol ），表示任何类[引⽤类型]类型的实例。
使用 AnyObject 声明的变量可以存储任何类类型的实例，但不能存储结构体、枚举或其他类型的实例。
AnyObject 是一个协议类型，所有类都隐式地遵循了 AnyObject 协议。

[Generics：]
泛型是 Swift中的⼀种编程技术，⽤于编写可以处理任意类型的代码。
泛型允许在编译时编写灵活的代码，以便在使用时指定类型。
使用泛型可以编写更加灵活和可重用的代码，而不需要在编译时知道确切的类型。
泛型可以用于函数、方法、类、结构体和枚举等地方，使得这些实体可以与任意类型一起工作。
泛型代码在编译时会进⾏类型检查，避免了使⽤ Any 时的类型不确定性问题。
<泛型类型由于在调用时能够确定具体的类型>[声明确定 运行时确定]
泛型的具体类型的确定是在程序运行时，而模板的实例化是在编译时确定的
例如：
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temp = a
    a = b
    b = temp
}

var intValue1 = 42
var intValue2 = 10
swapTwoValues(&intValue1, &intValue2)
print("intValue1: \(intValue1), intValue2: \(intValue2)") // 输出: intValue1: 10, intValue2: 42

var stringValue1 = "Hello"
var stringValue2 = "World"
swapTwoValues(&stringValue1, &stringValue2)
print("stringValue1: \(stringValue1), stringValue2: \(stringValue2)") // 输出: stringValue1: World, stringValue2: Hello

简而言之，Any 和 AnyObject 是用于处理不同类型的实例的机制，【而泛型则是一种编写灵活、可重用代码的机制】。
Any 可以表示任何类型的实例，
而 AnyObject 只能表示类类型的实例。
Generics 允许在编译时编写灵活的代码，以处理不同类型的数据。



#泛型类型

泛型类型使用 [Value Witness Table] 进行生命周期管理，Value Witness Table 由编译器生成;
其存储了该类型的 size、aligment（对齐方式）以及针对该类型的基本内存操作;
[编译器会尽量在编译时为每一个类型生成一个 (类型元信息对象——Type Metadata)];

[Type Metadata（类型元数据）]
对于泛型类型来说，通过 Type Metadata 也可以索引到 Value Witness Table! 
携带的类型元信息主要包含：类型的 Value Witness Table、类型的反射信息。

[每一种类型，在全局只有一个 Type Metadata，供全局共享]
对于内建基本值类型，如：Integer，编译器会在标准库中生成对应的 Type Metadata 。
其中Value Witness Table 是针对小的值类型 Value Witness Table。

对于引用类型，如：UIView，编译器也会在标准库中生成 Type Metadata。
其中Value Witness Table 是针对引用类型的标准 Value Witness Table。

对于自定义的引用类型，Type Metadata 会在我们的程序中生成，Value Witness Table 则由所有引用类型共享。
编译后的代码是如何使用 Type Metadata 的。如下所示为两种类型对 f<T> 的调用
struct MyStruct {
    var a: UInt8 = 0
    var b: UInt8 = 0
}

f(123)

f(MyStruct())
当使用 int 类型和 MyStruct 类型调用 f<T> 时，编译器生成的代码如下所示
 int val = 123;
 extern type *Int_metadata;
 f(&val, Int_metadata);


 MyStruct val;
 type *MyStruct_metadata = { ... };
 f(&val, MyStruct_metadata);
 
通过上述代码可以发现 两者的区别在于： 
[int 类型使用标准库中的 Type Metadata；] 
[自定义类型则使用针对自身生成的 Type Metadata。]

上述 Type Metadata 之所以能够在编译时生成，是因为我们在[调用时就能通过类型推导得出其类型]。
如果，[在调用时无法推断其类型]，则需要在]运行时动态生成 Type Metadata!】

对于泛型类型，编译器会在编译时生成一个 Metadata Pattern。 
Metadata Pattern 与 Type Metadata 的关系其实就是类与对象的关系。

以如下自定义泛型类结构为例:
 struct Pair<T> {
     var first: T
     var second: T
 }

 let pa = Pair(first: 1, second: 5)
[运行时根据绑定类型的 Type Metadata，结合 Metadata Pattern，生成最终的确定类型的 Type Metadata。]

在泛型类型调用方法时， Swift 会将泛型绑定为具体的类型。
[在编译时就能推导出泛型类型，编译器则会进行优化，]提高运行性能!
在运行时避免通过传递 Type Metadata 来查找各个域的偏移，从而提高运行性能!因此该实现的是静态多态。
在调用时能够确定具体的类型，所以不需要使用 Extential Container。

[但在协议类型调用方法时]，类型是 Existential Container，需要在方法内部进一步根据 [Protocol Witness Table] 进行方法索引，因此协议实现的是动态多态。

泛型特化是何时发生的?
在使用优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。
[如果调用方和类型是单独编译的]，就无法在调用方推断类型的内部实行，就无法使用优化。

为保证这些代码一起进行编译，这里就用到了[whole module optimization]。
而whole module optimization是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。
[whole module optimization (全模块优化)]
whole module optimization是用于Swift编译器的优化机制，从 Xcode 8 开始默认开启。
全模块优化的优势:
    •    编译器掌握所有方法的实现，可以进行内联和泛型特化等优化，通过计算所有方法的引用，移除多余的引用计数操作。
    •    通过知晓所有的非公共方法，如果方法没有被使用，就可以对其进行消除。
那么弊端则是会增加编译时间

泛型方法调用都是动态派发 (通过 vtable 或 PWT)，有一定的性能损耗。
为了优化此类损耗，Swift 编译器会对泛型进行特化 (Specialization of Generics)。
所谓特化就是为具体类型生成相应版本的函数，从而将泛型转成非泛型，实现方法调用的静态派发。

总的原则是在编译泛型方法时知道有哪些调用方，同时调用方的类型是可推演的



Swift 为每种类型生成了一份 Metadata Record，其中包含了 VWT (Value Witness Table)；

Protocol 使用 Existential Container 作为其内存模型，所有 Protocol 类型的变量都是 Existential Container 的实例；

Protocol 通过 PWT 实现方法动态派发 (Dynamic dispatch)；

泛型调用在满足一定条件时会进行特化，以提升性能。



#解释 Swift 中的泛型约束及其用途。
泛型约束在Swift中用于限制泛型类型的功能。这允许你定义一个或多个条件，泛型类型在实例化时必须满足这些条件。泛型约束的主要用途包括：

1、[类型约束]：可以指定泛型类型必须继承自特定类，或者必须遵守一个或多个特定协议。

2、[关联类型约束]：对于协议中的关联类型，可以指定它必须遵守的协议或是特定类型。

3、[泛型函数约束]：可以限制泛型函数的参数，使之只接受符合特定要求的类型。

通过使用泛型约束，你可以编写更加通用和灵活的泛型代码，同时确保代码的类型安全。
这使得代码既具有高度的复用性，又能保持清晰和准确的类型设计。




#Swift 的 static和class 区别

static 和 class 关键字都可以用来声明类型级别的属性和方法


静态属性和方法的使用方式：
static：可以用在类、结构体和枚举中，用来声明类型级别的属性和方法。
在类中，static 修饰的属性和方法可以被子类继承。
class：只能用在类中，用来声明类型级别的属性和方法。
在类中，class 修饰的属性和方法可以被子类继承、重写。
[class 不能修饰存储属， class 修饰的计算属性可以被重写,static 修饰的不能被重写 ]

注：如果你需要在子类中重写方法或属性，应该使用 class 关键字。
如果不需要重写，并且希望在类、结构体或枚举中统一处理类型级别的属性和方法，那么可以使用 static 关键字。



#Swift中 Struct 和 Class的区别是什么？ 你分别在什么时候使用？

[Struct是不能继承的] 而Class是能继承的，所以当我们需要继承父类的属性 方法等 需要使用Class。
Class是引用类型，Struct是值类型，当我们赋值给一个变量的时候Class是浅拷贝 只拷贝了引用，Struct是深拷贝 拷贝了一个新的实例。

内存管理上Class在堆上 是通过ARC进行管理，Struct在栈上 赋值到一个变量上时 会和变量的生命周期相同。

初始化上  class有一个默认的初始化函数，它会自动初始化类中所有的属性。
而对于struct来说，则需要手动实现初始化函数。此外，class还可以使用deinit函数来进行清理工作，而struct则没有deinit函数。

在Swift中，struct（结构体）是值类型，而类（Class）是引用类型。
这意味着struct遵循值类型的特性，即它们在赋值和传递时会进行复制。

而类则遵循引用类型的特性，即它们通过引用来处理实例的赋值和传递，多个引用可以指向类的同一个实例。
由于这两种类型的根本区别，Swift不支持为struct提供类似于类中的继承特性。
这是因为struct是值类型，它们的副本是独立的实体，而类的副本共享同一个实例。
如果struct可以继承，那么它们的复制行为可能会变得混乱和不可预测。


<因此Swift不支持struct的继承>。
但是，[你可以通过协议（Protocol）来实现类似于继承的行为]，协议定义了一组方法、属性和其他的要求，符合协议的类型必须实现这些要求。
这样，你可以通过扩展协议来提供默认实现，或者通过其他类型来提供额外的功能。这样做可以提供一定程度的灵活性和重用性。

struct与class的差异
Swift中类和结构体非常类似，都具有定义和使用属性、方法、下标和构造器等面向对象特性，
[但结构体不具有继承性，也不具备运行时强制类型转换、使用使用析构器和引用计数等能力！]
Swift中struct是值类型，而class是引用类型。
值类型的变量直接包含他们的数据，引用类型的变量存储对他们的数据引用，因此后者称为对象，
因此对一个变量操作可能影响另一个变量所有引用的对象。
对于值类型都有自己的数据副本，因此对一个变量操作不可能影响另一个变量

2. mutating关键字
// 在不修改class和struct的情况下添加一个Method：modifyCoderName(newName:）

// 类
extension ClassCoder {
    func modifyCoderName(newName:String) {
        
        self.name = newName
    }
}

// 结构体
extension StructCoder{
    mutating func modifyCoderName(newName:String) {
        self.name = newName
    }
}
[struct在func里面需要司改property的时候需要加上mutating关键字]，而class就不用。



内存分配：struct内存是分配到栈上，class内存是分配到堆上
栈内存的存储结构比较简单，可以理解为push到栈底pop出来，而要做的就是[通过移动栈针来分配和销毁内存]。
堆内存相比于栈，有着更为负责的存储结构。它的分配方式可以理解为[在堆中寻找合适大小的空闲内存块来分配内存]，把内存块重新插入堆里销毁内存。
当然然这些仅仅是堆内存相比栈内存消耗大的一方面，更重要的是[堆内存支持多线程操作]，响应就要通过同步等方式保证线程安全。

扩展：
数组越界为什么会崩溃，因为地址是连续的，取的地址有其他内容；
字典读取未知key不会崩溃



#Swift 中的值类型和引用类型有什么区别？
在Swift中，基本的分类型为值类型和引用类型，它们之间的主要区别在于如何存储和传递。

1、 值类型：每次赋值或传递时，都会进行拷贝操作，创建一个新的独立实例。
基本数据类型（如Int、String、Array等）和结构体（struct）、枚举（enum）是值类型。

2、 引用类型：赋值或传递时，不拷贝实例本身而是其引用或指针。
因此，多个变量可以引用同一个实例。类（class）是引用类型。

值类型的特性使得它在多线程环境下工作时更加安全，因为每个实例都有自己的独立拷贝，避免了意外修改。
而引用类型允许多个引用或者变量共享同一个实例，适合执行更复杂的数据结构和逻辑。




#Swift中的常量和OC中的常量有啥区别？
OC中的常量（const）是编译期决定的，Swift中的常量（let）是[运行时确定]的
 Swift 中 let 只是表明常量（只能赋值一次），其类型和值既可以是静态的，也可以是一个动态的计算方法，它们在 [runtime 运行时确定的]。



#String 与 NSString 的关系与区别？
1）本质区别：String是结构体，NSString是类，结构体是值类型，值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。


#Swift中枚举的高级用法有哪些？

1、 [关联值]：允许你存储与枚举成员值相关联的自定义类型的值。
这使得枚举可以存储更多的信息，并能根据不同的场景返回不同类型的关联值。

2、 [原始值]：枚举成员可以有原始值，
常见的原始值类型有字符串、字符或任何整数或浮点数类型。这使得枚举更容易在不同的上下文中转换和使用。

3、 [递归枚举]：通过在枚举成员前使用indirect关键字，枚举可以是递归的。
这意味着枚举成员的关联值可以是枚举本身的一个实例，非常适合表示具有递归结构的数据模型，如树形结构。

4、 [扩展和协议]：枚举可以遵循协议，并且可以通过扩展来增加额外的功能。这为在枚举上定义共通的行为提供了一种强大的方式。

这些高级用法提升了枚举在Swift编程中的灵活性和表达能力。


#-----------

#Swift 中的错误处理机制如何工作？

Swift 中的错误处理机制允许程序在运行时检测和响应错误条件。Swift 提供了强大的错误处理模型，包括抛出、捕捉和传递错误。

1、 [定义错误类型]：首先，通过实现Error协议来定义可能发生的错误类型。这些错误类型通常是枚举，用来表示不同的错误情况。

2、 [抛出错误]：使用throw关键字来抛出一个错误。这通常发生在函数内部，当函数遇到无法解决的问题时，它会抛出一个错误，以表示失败。

3、 [标记抛出错误的函数]：在函数声明中使用throws关键字来标记这个函数可能会抛出错误。这意味着调用这个函数的代码需要处理这些错误。

4、 [捕捉和处理错误]：使用do-catch语句来捕捉和处理错误。
在do代码块中调用可能抛出错误的代码。如果在do块中抛出了错误，控制流会转移到catch块，让你有机会响应和处理错误。

5、 使用[try、try?和try!]来调用抛出错误的函数，
分别表示：检查错误并使用do-catch处理、
将结果转换为可选值（如果发生错误则结果为nil）、
断言调用不会抛出错误（如果实际抛出错误，则会触发运行时错误）。

这种错误处理机制使得Swift代码能够优雅地处理错误和异常情况，提高了程序的健壮性和可维护性。


#Swift 中的错误处理模型如何支持复杂的错误处理逻辑？
Swift的错误处理模型设计得既强大又灵活，能够支持复杂的错误处理逻辑：

1、 Swift中的错误处理使用throw来表示一个函数可以抛出错误，使用throws标记可抛出错误的函数，使用try、try?或try!来调用这些函数。

2、 使用do-catch块来捕获和处理错误。do块中的代码表示可能会抛出错误的操作，catch块用来捕获和处理这些错误。
可以有多个catch块来捕获不同类型的错误，并对每种错误做出相应的处理。

3、 try?可以将错误转换为可选值。如果函数抛出错误，表达式的结果为nil，这允许你忽略错误的具体类型，只关心操作是否成功。

4、 defer语句允许你在函数返回前执行一段代码，无论是正常返回还是通过抛出错误返回。
这对于资源清理非常有用，确保了即使发生错误也能执行必要的清理工作。

5、 Swift的错误处理模型还支持将错误传递给调用者。
这意味着函数可以抛出错误而不直接处理它，让上层调用者负责处理，这有助于减轻单个函数或方法的责任，使错误处理逻辑更加集中和一致。

Swift的错误处理模型通过这些特性，提供了一套强大的工具来编写可靠和维护性高的错误敏感型代码。



#描述 Swift 中 ARC（自动引用计数）的工作原理

自动引用计数（ARC）是Swift中用于[内存管理的机制]。ARC自动跟踪和管理应用程序的内存使用，
确保当实例不再被需要时释放它们占用的内存。ARC的工作原理如下：

1、 每当创建一个类的新实例时，ARC 会分配一块内存来存储该实例的信息，包括实例的类型信息以及与之相关的存储属性。

2、 为了确保实例在使用中不被销毁，ARC 会跟踪和计算每个实例的引用次数。每次你将实例赋给属性、常量或变量时，引用计数会加一。

3、 当引用计数变为零时，即没有任何属性、常量或变量引用该实例，ARC 会自动释放该实例所占用的内存。

4、 为了防止循环引用导致的内存泄漏，Swift 使用强引用（默认行为）、弱引用和无主引用来区分引用类型。弱引用和无主引用不会增加实例的引用计数。

通过这种方式，ARC帮助Swift开发者管理内存，大大简化了内存管理的工作，但开发者仍需[注意避免循环引用]等问题。


#Swift 中如何实现线程安全？
实现线程安全的方法在Swift中是至关重要的，尤其是在多线程环境下操作共享资源时。以下是实现线程安全的几种常用方法：

1、[使用串行队列]：创建一个串行DispatchQueue，并将所有对共享资源的访问操作提交到这个队列中。
由于串行队列一次只执行一个任务，这保证了同一时间只有一个线程能访问该资源。

2、[使用同步锁]：Swift可以使用DispatchSemaphore或NSLock等锁机制来同步对共享资源的访问。
在访问资源前加锁，在访问后解锁，以此来保证在任何时刻只有一个线程能访问该资源。

3、[使用原子操作]：对于简单的数据类型，可以使用原子操作来实现线程安全。
原子操作是系统级别的，能够保证操作的完整性，不会被其他线程打断。

4、[使用线程安全的数据结构]：Swift标准库和第三方库提供了一些线程安全的数据结构，如ThreadSafeArray或Atomic等，
这些数据结构内部已经实现了线程安全的保护。

通过这些方法，可以有效地在Swift应用中实现线程安全，避免数据竞争和条件竞争等多线程问题。




#解释 Swift 中的泛型编程及其好处。

Swift中的泛型编程允许你编写灵活、可重用的函数和类型，它们可以工作于任意类型，条件是这些类型满足定义的要求。泛型编程的好处包括：

1、[类型安全]：泛型代码让你能够写出抽象和可复用的函数和类型，同时保留类型检查的优点。这意味着编译器可以自动检测类型错误。

2、[减少代码量]：使用泛型可以减少重复代码，因为你可以用单一的函数或类型来处理不同类型的数据，
而不是为每种数据类型编写特定的函数或类型。

3、[提高性能]：泛型代码在编译时被实例化，这意味着编译器生成的代码已经是[针对特定类型优化]的。
这可以在保持代码抽象和灵活性的同时，提供与[非泛型代码]相同的运行时性能。

4、[提升表达能力和灵活性]：泛型让库和框架的设计者能够提供高度灵活和可配置的API，而无需牺牲类型安全或性能。

泛型是Swift语言中强大的特性之一，通过使用泛型，开发者可以编写更清晰、更抽象且高度复用的代码。



#解释 Swift 中的可选链式调用及其用途。

可选链式调用是一种在当前可选值可能为nil的情况下查询和调用属性、方法及下标的方式。如果可选值有值，那么调用就会成功；如果可选值是nil，则调用返回nil。可选链式调用的用途包括：

1、 [简化对可选类型值的查询]。
它允许你编写一条语句来尝试访问多层可选类型的属性、方法和下标，而无需每次查询都进行显式的解包。

2、 [增强代码的安全性]。
使用可选链式调用可以避免运行时的nil值错误，因为它会在尝试访问的任何一个点上值为nil时，整个表达式的结果也为nil。

3、 [提高代码的简洁性和可读性]，避免冗长的条件判断语句。

可选链式调用是处理Swift中可选类型的一个非常有效和安全的工具，使得操作可选类型更加灵活和简洁。


#Swift 中的可选类型是什么，它如何增加语言的安全性？
可选类型（Optional）是Swift语言的一个核心特性，用于处理值可能缺失的情况。可选类型表示两种可能：要么有值，你可以解包使用这个值；要么根本没有值。

1、可选类型通过在类型后面添加?来表示，例如Int?表示“可选的Int类型”，它可以包含一个Int值或者没有值。

2、可选类型增加了Swift语言的安全性，因为它强制你明确处理值缺失的情况。
这避免了在其他语言中常见的空指针异常，因为Swift编译器要求你使用可选绑定（if let或guard let）、强制解包（!）或可选链式调用等方式来安全地处理可选类型。

3、这种方式促使开发者在编写代码时就[显式地考虑和处理值]可能不存在的情况，从而避免运行时错误和提高程序的健壮性。




#Swift 中的属性观察器有哪些，它们各自有什么用途？

Swift中的属性观察器包括willSet和didSet，它们用于监控属性值的变化，从而可以在属性的值即将更改和已经更改时执行自定义操作。这两个观察器的用途如下：

1、 willSet观察器在属性的值即将更改之前被调用。
它使你可以读取即将被设定的新值，并可以执行一些自定义代码。willSet观察器可以带有一个默认参数名newValue，如果你不指定参数名，可以直接使用newValue来访问新的属性值。

2、 didSet观察器在属性的值已经更改后立即被调用。
它使你可以读取已经被更改的旧值，并可以基于新值执行一些自定义代码。didSet观察器可以带有一个默认参数名oldValue，如果你不指定参数名，可以直接使用oldValue来访问旧的属性值。

属性观察器提供了一种强大的方式来响应属性值的变化，使得开发者可以在适当的时机插入自己的逻辑或执行一些清理工作。




#Swift 中的 defer 语句有什么用途？
在Swift中，defer语句用于在作用域{}[即将离开当前代码块前执行一段代码]，无论是由于抛出错误而离开还是正常的离开。
这个语句主要用于清理工作或释放资源，确保即使在发生错误时也能执行某些必要的代码。使用defer的好处包括：

1、[确保代码的执行]：无论函数是通过哪种路径退出的，defer块中的代码都会被执行。

2、[提高代码清晰度]：将清理或关闭资源的代码放在defer语句中，可以让你的逻辑更加集中，更容易阅读和维护。

3、[避免代码重复]：在多个退出点需要执行相同的清理代码时，使用defer可以避免代码重复。

defer语句的这些特性使得它成为管理资源和保证代码执行的有力工具。

注：如果有多个defer，[后加的先执行]， return后的不执行





#什么时候使用 final？

1）final关键字可以在class、func和var前修饰，表示不能被继承或重写，否则编译器会报错， 
可以将类或者类中的部分实现保护起来，从而避免子类破坏。

2）它可以显示的指派函数的派发机制。 直接派发
限制类的继承：通过在类的定义前加上 final 关键字，可以防止其他类继承该类。
这样做可以确保类的实现不会被修改或扩展，从而提高代码的安全性和稳定性。

限制属性的重写：通过在属性的定义前加上 final 关键字，可以防止子类重写该属性。这样做可以确保父类的属性在子类中保持不变。
限制方法的重写：通过在方法的定义前加上 final 关键字，可以防止子类重写该方法。这样做可以确保父类的方法在子类中保持不变。
final 关键字用于限制类、属性和方法的继承和重写，从而提高代码的安全性和稳定性。特别是在框架或库中希望确保类的⾏为不被修改时⾮常有⽤


#Swift 的 extension

extension（扩展）允许你在不修改原始代码的情况下，扩展现有类型的功能，包括类、结构体、枚举和协议
添加新的方法：可以在已有的类型上添加新的实例方法或类型方法。
添加新的计算属性：可以在已有的类型上添加新的计算属性。
定义新的初始化方法：可以在已有的类型上定义新的初始化方法
遵循协议：可以使已有的类型遵循新的协议。
提供默认实现：可以在协议的扩展中为协议中的方法提供默认实现。


#Swift的Copy On Write机制了解过吗？

1）Swift中参数传递是值类型传递，它会对值类型进行copy操作，当传递一个值类型变量时（变量赋值，函数传参），
它传递的是一份新的copy值，两个变量指向不同的内存区域。如果频繁操作的变量占内存较大，会产生性能问题。

2）Copy On Write是一种优化值类型copy的机制，
对String、Int、Float等非集合数据类型，赋值直接拷贝，对于Array等集合类型数据，只有传递的内容值[改变后才进行拷贝操作]。
3）Copy On Write的实现：set函数中[判断是否存在多个引用]，只有存在多个引用的情况下才会进行拷贝操作。
另外，[自定义结构体是不支持Copy On Write的]。

Swift中的CopyOnWrite(COW)技术是一种内存优化技术，其原理是在需要修改数据时才进行拷贝，以避免不必要的内存消耗。
COW的实现主要依赖于Swift中的结构体和类的特性。
对于结构体而言，它是值类型，每次赋值都会使用新的内存地址；
而类则是引用类型，每次赋值只是改变了指向内存地址的指针。

通过这些特性，Swift 可以在需要修改数据时，先判断数据是[否被其他地方引用]，如果[没有]，则在[原有的内存]上进行修改；
如果有，则先进行拷贝，再在新内存上进行修改。这样，只有在实际需要修改数据时，才会进行内存拷贝，从而避免了不必要的内存开销。

因此，COW 技术在 Swift 中是一种非常有效的内存优化技术，可以帮助我们在保证效率的同时，最大程度地节约内存。

``var names = ["aa","bb","cc","dd"]
    
    var firstName = names[0]

    names[0] = "aa01" //直接改
    firstName = "aa02"
    
    print(names) //["aa01", "bb", "cc", "dd"]
    print(firstName)``
    
    
#In-Out（inout关键字）参数了解过吗？

默认情况下，函数参数默认是常量，试图从函数体中去改变一个函数的参数值会报编译错误。
如果希望函数修改参数值，并在函数调用结束后仍然保留。这个时候就需要用到inout关键字。
inout关键字修饰的变量传递过程：
1）函数被调用，参数值会被拷贝
2）在函数体中，修改的是拷贝的值
3）函数返回时，拷贝的值会赋值给原参数
注意事项：
[inout关键字只能修饰变量]，无法修饰常量，因为常量和字面量不能被修改。
inout参数不能有默认值，可变参数不能标记为inout。
调用函数的时候，应该在变量名前放置&符号表示该变量可以由函数修改。
    
// 可变参数
func funcName4(names: String..., address: String) -> String {
    var str = "学生"
    for name in names[0...] {
        str.append(name)
        str.append(" ")
    }
    str.append("住在")
    str.append(address)
    return str
}
//print(funcName4(names: "小明", "小红", "小黑", address: "和磡村"))
// 打印 学生小明 小红 小黑 住在和磡村


#Swift Protocol 实现机制
Existential Container
协议类型：一般的Existential Container数据结构为:

数组中每个元素的大小都是固定的 5 个 word，解决了数组元素下标快速定位的问题。
因为有 Value Buffer 的存在，我们可以将不同大小的值类型存放到 Value Buffer 中，小于等于 3 个 word 的值直接存储，更大的则通过保存引用地址的方式存储。
通过 Value Witness Table，我们可以找到这个值类型的相关生命周期的管理函数。
通过 Protocol Witness Table，我们可以找到协议的具体实现函数的地址。

structOpaqueExistentialContainer{

void *fixedSizeBuffer[ 3];
Metadata*type;
WitnessTable*witnessTables[ NUM_WITNESS_TABLES];

};

如上， OpaqueExistentialContainer 包含3个成员：

fixedSizeBuffer — 3 个指针大小的 buffer 空间，
当真实类型的 size (内存对齐后的大小) [小于 3 个字]时则其内容[直接存储]在 fixedSizeBuffer 中，
否则在 [heap] 上另辟空间存储，并将指针存储在 fixedSizeBuffer 中；



#Swift 有什么⽅案能监听属性值的变化，不使用ObjC的KVO
1、属性观察器
属性观察器允许在属性值即将被设置或已经被设置时执行特定的代码
2、Swift 闭包
使用闭包可以在属性值发生变化时执行特定的代码。这种方法适用于自定义的类和结构体，但不适用于 Swift 的基本类型。

3、[Swift Combine 框架]
Combine 框架是 Swift 中用于处理异步事件流的框架，可以用于监听属性值的变化。



#Swift 高阶函数
Swift 中的高阶函数是指那些以其他[函数作为参数或者返回值的函数]。这些函数通常用于简化代码、提高可读性和功能性。常见的高阶函数包括 map、filter、reduce 、flatMap、compactMap、allSatisfy 等。

map 函数用于对集合中的每个元素应用一个指定的转换闭包，然后返回一个包含转换结果的新集合
filter 函数用于从集合中选择满足指定条件的元素，并返回一个包含满足条件的元素的新集合
reduce 函数用于将集合中的所有元素组合成单个值，并返回该值
flatMap 函数用于对集合中的每个元素应用一个转换闭包，并将结果拼接成一个新的集合
compactMap 函数用于对集合中的每个元素应用一个转换闭包，并过滤掉结果中的 nil 值
allSatisfy 函数用于检查序列中的所有元素是否都满足指定条件


#Swift 使用过zip函数


#Swift 中如何实现单例模式？
在Swift中，单例模式的实现通常采用静态属性和私有初始化方法来确保一个类仅有一个实例。具体做法是：定义一个静态属性来存储这个单例实例，然后将类的初始化方法设为私有，以阻止外部通过构造函数创建实例。

实现步骤如下：

1、 创建一个名为shared的静态属性，这个属性将存储单例类的唯一实例。

2、 将类的构造器声明为私有，使用private init()。这样外部代码不能直接调用这个构造器来创建实例。

3、 通过ClassName.shared的方式访问这个类的单例实例。

这种方法既保证了单例模式的核心要求——确保一个类仅有一个实例，同时也利用了Swift语言的特性来简化实现。



#解释 Swift 中的内存泄漏，以及如何避免？

内存泄漏是指程序中已分配的内存未能被释放，即使它已经不再被应用程序使用，导致内存的浪费和应用程序性能的下降。
在Swift中，内存泄漏通常与不恰当的引用类型使用有关，特别是闭包和类实例之间的循环强引用。

1、避免内存泄漏的关键方法之一是使用弱引用（weak）和无主引用（unowned）。
当你预期引用可能会变成nil时，应该使用弱引用；如果[引用始终不会变成nil，使用无主引用]。

2、在闭包中，使用[weak self]或[unowned self]捕获列表来打破循环强引用是一种常用的做法。
这样可以确保闭包内部对实例的引用不会阻止Swift的自动引用计数（ARC）机制释放实例。

3、使用自动引用计数（ARC）工具和内存分析器来识别和修复内存泄漏。
Xcode提供了强大的工具，如Leaks和Allocations，来帮助开发者找到和修复内存泄漏问题。



#Swift 中的动态派发是什么，它是如何工作的？

动态派发是一种运行时决定方法调用的机制。
在Swift中，动态派发主要通过虚拟派发表实现，这涉及到引用类型如类（class）。
动态派发允许Swift在运行时选择响应消息的最终实现，这为方法重写和多态提供了基础。

1、当你调用一个类的方法时，Swift运行时会查找这个类的虚拟派发表，找到对应方法的实际实现地址，然后跳转到这个地址执行方法。

2、由于动态派发的存在，Swift可以在运行时而非编译时决定调用哪个方法的实现，这增加了程序的灵活性，但也可能略微降低性能。

3、Swift中默认情况下类的方法是动态派发的。
通过使用final关键字标记方法或类，可以阻止方法被重写，从而允许编译器优化调用，采用更快的静态派发。

动态派发是面向对象编程中的一个关键概念，它使得子类可以定制或改变继承而来的行为。




#Swift 中如何高效地使用枚举来处理不同的状态和事件？

在Swift中，枚举是处理不同状态和事件的理想选择，因为它们让[相关联的值和逻辑组织]在一起，清晰而且类型安全。高效使用枚举的方法包括：

1、利用枚举的[关联值]来存储与每个枚举案例相关的额外信息。这使得枚举可以表达更复杂的[状态或事件]，同时保持代码整洁和组织良好。

2、使用枚举来定义一组相关的命令或操作，然后通过switch语句来匹配并执行相应的逻辑。这种方式使得新增或修改命令变得非常简单。

3、结合使用枚举和协议，可以定义一组遵循共同协议的枚举，这样即使它们代表不同的状态或事件，也能以统一的方式处理。

4、利用枚举的原始值（通常用于表示静态或不变的数据）和计算属性，可以为枚举值附加更多的上下文信息，增加代码的可读性和易用性。

通过这些方法，枚举成为了Swift中管理状态和事件的强大工具，既增强了代码的表达能力，又保持了严格的类型安全。



#Swift 中的编译时多态性和运行时多态性有何区别？
编译时多态性和运行时多态性是面向对象编程中的两种多态性形式，它们在Swift语言中也有所体现：

1、 [编译时多态性（也称为静态多态性）]主要通过方法重载和泛型实现。
在编译时，编译器根据调用的参数类型和数量决定使用哪个具体的方法或函数。
泛型也是编译时多态性的一个例子，它允许函数或类型与任何数据类型一起工作，类型检查发生在编译时。

2、 [运行时多态性（也称为动态多态性）]在Swift中主要通过继承和协议来实现。
它允许在运行时决定调用哪个对象的哪个方法，这依赖于对象的实际类型。
在Swift中，类的继承关系和协议的实现提供了运行时多态性，使得同一接口可以有多个实现，具体使用哪个实现在运行时通过动态派发来决定。

[编译时多态性提供了更好的性能，因为方法调用的解析在编译时完成]；
而运行时多态性提供了更高的灵活性，允许更加动态的行为，但可能会略微牺牲性能。



#在Swift中，如何使用类型别名提高代码的可读性和维护性？
类型别名在Swift中是通过typealias关键字定义的，它可以为现有类型提供另一个名称。使用类型别名可以提高代码的可读性和维护性：

1、 对于复杂的类型，如泛型类型或元组，使用类型别名可以简化这些类型的表示，使它们更容易理解和使用。

2、 类型别名可以用来表达类型的用途，从而使代码的意图更加明确。
例如，将String类型的别名定义为UserID或JSONString，可以让这些字符串的用途一目了然。

3、 在协作开发中，使用类型别名可以帮助团队成员更快地理解代码。
如果项目后期需要更改类型，只需修改类型别名的定义，而不必修改使用该类型的所有代码，这大大降低了维护成本。

4、 类型别名也可以用于创建条件编译块中的特定平台类型，提高代码的可移植性和灵活性。

通过合理使用类型别名，开发者可以编写出更清晰、更易维护的Swift代码。


#Swift 中的访问级别如何影响API设计和模块结构？
Swift中的访问级别控制着类型和成员（属性、方法等）的可见性和可访问性，对API设计和模块结构有重要影响：

1、 明确的访问级别有助于定义一个清晰的API边界。
通过将内部实现细节设为private或fileprivate，可以隐藏不希望外部使用者访问的部分，只暴露必要的接口给外部使用。

2、 使用public或open访问级别可以明确指定哪些接口是设计用来被其他模块或框架使用的。
open访问级别还允许在模块外被继承或重写，适用于设计可扩展的框架。

3、 合理的访问级别设置有助于模块的解耦。通过限制跨模块的直接访问，可以更容易地维护和重构代码，因为改动的影响范围更加可控。

4、 在大型项目或团队协作中，合理利用访问级别可以减少意外的修改和使用错误，提高代码的安全性和稳定性。

访问级别是Swift中设计高质量API和模块化结构的重要工具，有助于创建清晰、易于维护和扩展的代码库。



#Swift 中的函数式编程特性有哪些？
Swift中的函数式编程特性体现在它支持不可变性、一等函数（First-class functions）、高阶函数等概念。这些特性提供了强大的工具，使得编程范式更加灵活和表达力强。

1、 [不可变性]：Swift鼓励使用不可变数据结构，这意味着一旦数据被创建，它就不能被改变。这有助于减少程序中的错误和副作用。

2、 一等函数：在Swift中，函数是"一等公民"，意味着函数可以被赋值给变量、作为参数传递给其他函数，以及作为其他函数的返回值。

3、 [高阶函数]：Swift标准库提供了多种高阶函数，如map、filter、reduce等，
它们允许你以声明式的方式处理数据集合，提高代码的简洁性和可读性。

4、 [闭包]：作为Swift函数式编程的核心，闭包允许你捕获和存储上下文中的任意常量和变量的引用。这是实现函数式编程中许多高级模式的基础。

通过这些函数式编程特性，Swift允许开发者编写出更清晰、更易于维护的代码，同时提高了代码的表达力和灵活性。



#如何在Swift中实现并发编程？
Swift中实现并发编程主要依靠Grand Central Dispatch ([GCD])和[Operation Queues]两种机制，以及Swift 5.5引入的异步/等待[（async/await）]模式。

1、 Grand Central Dispatch (GCD)：是一种基于C语言的低层次并发API，提供了强大的工具来管理并发任务。通过使用队列（Dispatch Queue），开发者可以异步或同步地执行任务。GCD支持串行队列和并发队列，允许你控制任务的执行方式。

2、 Operation Queues：是基于对象的高级并发API。它允许你封装任务为Operation对象，并加入到OperationQueue中。Operation提供了更多控制，包括设置任务依赖、优先级和取消操作。

3、 异步/等待（async/await）：Swift 5.5中引入的新特性，提供了一种更简洁和直观的方式来处理异步代码。使用async标记的函数可以在其中执行耗时操作而不阻塞当前线程，await用于调用异步函数，直到它完成。

这些并发编程工具和模型提供了不同的抽象级别，让Swift开发者可以根据需要选择最合适的方式来实现并发，从而提高应用的性能和响应性。




#Swift 中的泛型如何用于提高代码复用性？
Swift中的泛型是编程中一种允许你编写灵活、可重用函数和类型的方法，它可以工作于任何类型。泛型的主要目的是减少代码重复，提高代码的复用性和清晰度。

1、 [泛型函数]：你可以创建可以接受任何类型参数的函数。这意味着相同的函数可以用于不同类型的输入，避免了为每种类型编写重复的代码。

2、 [泛型类型]：除了函数，Swift允许你定义泛型类型，如自定义的数据结构，它们可以与任何类型一起使用。这对于创建通用的数据结构如栈、队列和链表等特别有用。

3、 [类型约束]：泛型代码还可以通过类型约束来定义某些类型必须遵循的特定协议，这提供了使用泛型时的灵活性和强大的类型安全。

4、 [泛型扩展]：Swift允许对泛型类型进行扩展，为泛型类型添加新的功能。这使得你可以对泛型类型进行高度定制化的扩展，而无需修改原始的泛型定义。

通过使用泛型，Swift开发者可以编写更加抽象和通用的代码库，
这些代码可以工作于多种类型上，减少了重复代码，提高了项目的维护性和可扩展性。




#解释Swift中的类型推断，它是如何工作的？
类型推断是Swift编译器的一个特性，它可以自动推断表达式的类型，从而减少编程时需要明确指定类型的情况。类型推断的工作原理基于编译器能够分析你的代码中的值和表达式，然后推断出它们的具体类型。

1、 基于初始值的推断：当你给一个新的变量或常量赋值时，Swift可以推断出这个变量或常量的类型，因为每个字面量都有一个明确的类型。

2、 基于上下文的推断：在很多情况下，即使没有直接的字面量赋值，编译器也可以根据上下文信息推断出类型，
例如函数的参数类型、返回类型或者赋值表达式的左侧类型。

3、 集合类型的推断：对于数组和字典，Swift可以根据集合中元素的类型推断出整个集合的类型。

类型推断使得Swift代码更加简洁和易读，同时保持了类型安全的特性。它减少了需要手动指定类型的需求，让编码过程更加流畅。


#在Swift中，如何使用协议来实现多态性？
在Swift中，协议是定义一组方法、属性和其他要求的蓝图。通过使不同的类型遵守同一个协议，可以在这些类型上实现多态性，这意味着即使它们是不同的类型，也可以以相同的方式使用它们。

1、 定义协议：首先定义一个或多个协议，声明需要实现的方法和属性。

2、 [实现协议]：不同的类、结构体或枚举可以遵守这些协议，并提供具体的实现。

3、 [使用协议类型]：在函数、方法或者变量中使用协议类型作为类型标注。这允许你接受任何遵守该协议的实例，从而实现多态性。

4、 协议作为类型：协议本身可以作为类型使用，这意味着你可以声明一个[协议类型的变量或常量]，它们在运行时可以引用任何遵守该协议的实例。

通过这种方式，Swift中的多态性允许不同的对象以统一的接口被处理，同时保留各自的实现细节，这增强了代码的灵活性和可重用性。



#Swift 中的动态库和静态库有什么区别？
Swift中的动态库（Dynamic Libraries）和静态库（Static Libraries）都是代码复用的方式，它们允许开发者将代码封装起来供其他项目引用，但在链接和分发应用时有着本质的区别：

1、 静态库：在编译时，静态库的代码会被整合到最终的可执行文件中。
每个使用静态库的应用都会有一份库的拷贝，这意味着静态库的更新需要重新编译应用。

2、 动态库：与静态库不同，动态库在应用运行时被加载。
这意味着多个应用可以共享同一份动态库的拷贝，减少了应用的体积。当动态库更新时，不需要重新编译使用它的应用，只需替换动态库文件即可。

3、 内存占用：使用静态库会增加应用的总体积，因为库的代码被整合进了应用。
而动态库虽然可以减少单个应用的体积，但如果有多个应用同时运行并使用同一动态库，它们将共享这份库的内存拷贝。

4、 兼容性和版本控制：动态库更易于管理和更新，因为它们是独立于应用外的。
但这也带来了版本兼容性问题，需要确保应用与动态库的兼容性。

5、 安全性和隐私：静态库被编译进应用中，更不易被替换或篡改。
而动态库由于是在运行时加载，可能面临被替换的风险，但也使得安全更新更加容易实施。



#self 做为变量名

doSomething(then: { [weak self] in
    guard let strongSelf = self { else return }
    strongSelf.doSomethingElse()
)
Swift 4.2 可以使用 self 做为变量名啦！

guard let self = self else { return }

var number: Int? = nil
if let self = number {
    print(self) // 这里的 self 是 number：Int
}



#不通过继承，代码复用（共享）的方式有哪些
在swift 文件里直接写方法，相当于一个全局函数。
extension 给类直接扩展方法。


#实现一个 min 函数，返回两个元素较小的元素

func min<T : Comparable>(_ a : T , b : T) -> T {
    return a < b ? a : b
}



#如何声明一个只能被类 conform 的 protocol
protocol OnlyClassProtocol : class {

}


#声明一个只有一个参数没有返回值闭包的别名
typealias NoReturn = (String) -> Void


#下面的代码会不会崩溃，说出原因
var mutableArray = [1,2,3]
for _ in mutableArray {//这个数量
  mutableArray.removeLast() 
}



#给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明
extension Array where Element == String {

}




#定义静态方法时关键字 static 和 class 有什么区别

struct 只能用static
class 的属性只能用 static , 其他地方都能随便用。



